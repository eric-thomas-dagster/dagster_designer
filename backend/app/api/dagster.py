"""API endpoints for Dagster CLI operations."""

from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
from typing import Any

from ..services.dagster_cli_service import dagster_cli_service
from ..services.project_service import project_service
from ..services.component_installer import component_installer

router = APIRouter(prefix="/dagster", tags=["dagster"])


class CreateProjectRequest(BaseModel):
    """Request to create a Dagster project."""

    project_id: str
    project_name: str


class ScaffoldComponentRequest(BaseModel):
    """Request to scaffold a component."""

    project_id: str
    component_type: str
    component_name: str
    options: dict[str, Any]


class AssetInfo(BaseModel):
    """Information about a Dagster asset."""

    key: str
    group_name: str | None = None
    description: str | None = None
    deps: list[str] = []
    metadata: dict[str, Any] = {}


class AssetPreviewResponse(BaseModel):
    """Response containing asset preview."""

    success: bool
    assets: list[AssetInfo]
    asset_count: int
    error: str | None = None


@router.post("/create-project")
async def create_dagster_project(request: CreateProjectRequest):
    """Create a new Dagster project using official CLI.

    This uses `uvx create-dagster@latest project` to create a proper project structure.

    Args:
        request: Project creation request
    """
    try:
        project_path, output = dagster_cli_service.create_dagster_project(
            request.project_name
        )

        # Update the project metadata with the path
        project = project_service.get_project(request.project_id)
        if not project:
            raise HTTPException(status_code=404, detail="Project not found")

        # Store the Dagster project path in project metadata
        # (You might want to add a field to the Project model for this)

        return {
            "success": True,
            "project_path": str(project_path),
            "message": "Dagster project created successfully",
            "output": output,
        }

    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Unexpected error: {e}")


@router.post("/scaffold-component")
async def scaffold_component(request: ScaffoldComponentRequest):
    """Scaffold a component using dg CLI.

    This uses `dg scaffold defs` to properly create component configuration.

    Args:
        request: Component scaffold request
    """
    # Get project to find Dagster project path
    project = project_service.get_project(request.project_id)
    if not project:
        raise HTTPException(status_code=404, detail="Project not found")

    # Get the Dagster project path
    # For now, assume it's in the same name as our project
    dagster_project_path = dagster_cli_service.projects_dir / project.name

    if not dagster_project_path.exists():
        raise HTTPException(
            status_code=404,
            detail="Dagster project not found. Create it first.",
        )

    try:
        component_file, output = dagster_cli_service.scaffold_component(
            dagster_project_path,
            request.component_type,
            request.component_name,
            request.options,
        )

        return {
            "success": True,
            "component_file": str(component_file),
            "message": "Component scaffolded successfully",
            "output": output,
        }

    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Unexpected error: {e}")


@router.get("/preview-assets/{project_id}", response_model=AssetPreviewResponse)
async def preview_assets(project_id: str):
    """Preview assets that will be generated by the project.

    This loads the Dagster definitions and inspects the resulting assets.

    Args:
        project_id: Project ID
    """
    # Get project
    project = project_service.get_project(project_id)
    if not project:
        raise HTTPException(status_code=404, detail="Project not found")

    # Get the Dagster project path
    dagster_project_path = dagster_cli_service.projects_dir / project.name

    if not dagster_project_path.exists():
        return AssetPreviewResponse(
            success=False,
            assets=[],
            asset_count=0,
            error="Dagster project not initialized. Create it first.",
        )

    try:
        result = dagster_cli_service.load_definitions(dagster_project_path)

        return AssetPreviewResponse(
            success=result.get("success", False),
            assets=[AssetInfo(**asset) for asset in result.get("assets", [])],
            asset_count=result.get("asset_count", 0),
            error=result.get("error"),
        )

    except Exception as e:
        return AssetPreviewResponse(
            success=False,
            assets=[],
            asset_count=0,
            error=str(e),
        )


@router.get("/validate-project/{project_id}")
async def validate_project(project_id: str):
    """Validate a Dagster project.

    Args:
        project_id: Project ID
    """
    # Get project
    project = project_service.get_project(project_id)
    if not project:
        raise HTTPException(status_code=404, detail="Project not found")

    # Get the Dagster project path
    dagster_project_path = dagster_cli_service.projects_dir / project.name

    if not dagster_project_path.exists():
        raise HTTPException(status_code=404, detail="Dagster project not found")

    try:
        is_valid, message = dagster_cli_service.validate_project(dagster_project_path)

        return {
            "valid": is_valid,
            "message": message,
        }

    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/list-components")
async def list_dagster_components():
    """List available Dagster components using dg CLI."""
    try:
        components = dagster_cli_service.list_components_from_dg()

        return {
            "components": components,
            "total": len(components),
        }

    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/component-options/{component_type:path}")
async def get_component_options(component_type: str):
    """Get scaffold options for a component type.

    Args:
        component_type: Full component type (e.g., dagster_dbt.DbtProjectComponent)
    """
    try:
        options = dagster_cli_service.get_component_scaffold_options(component_type)

        return {
            "component_type": component_type,
            "options": options,
        }

    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


# Component Installation Endpoints


class InstallComponentRequest(BaseModel):
    """Request to install a component package."""

    project_id: str
    component_type: str


@router.post("/install-component")
async def install_component(request: InstallComponentRequest):
    """Install a component package using uv add.

    This dynamically installs the required package for a component type.
    For dbt components, automatically detects and installs the correct adapter.

    Args:
        request: Installation request
    """
    # Get project
    project = project_service.get_project(request.project_id)
    if not project:
        raise HTTPException(status_code=404, detail="Project not found")

    # Get the Dagster project path using the correct method
    dagster_project_path = project_service._get_project_dir(project)

    if not dagster_project_path.exists():
        raise HTTPException(
            status_code=404,
            detail="Dagster project not found. Create it first.",
        )

    try:
        # Special handling for dbt components
        if "dbt" in request.component_type.lower():
            # Detect the adapter from any cloned repos
            adapter_type = 'duckdb'  # default

            # Look for git repos in the project directory
            for item in dagster_project_path.iterdir():
                if item.is_dir() and not item.name.startswith('.') and item.name not in ['src', 'tests']:
                    detected = project_service._detect_dbt_adapter(item)
                    if detected != 'duckdb':  # Use non-default if found
                        adapter_type = detected
                        break

            adapter_package = f"dbt-{adapter_type}"

            # Install both dagster-dbt and the adapter
            import subprocess
            print(f"Installing dagster-dbt and {adapter_package} for dbt component...")
            result = subprocess.run(
                ["/Users/ericthomas/.local/bin/uvx", "--with", "uv", "uv", "add", "dagster-dbt", adapter_package],
                cwd=str(dagster_project_path),
                capture_output=True,
                text=True,
                timeout=300,
            )

            if result.returncode != 0:
                raise HTTPException(
                    status_code=400,
                    detail=f"Failed to install dbt packages: {result.stderr}"
                )

            message = f"Installed dagster-dbt and {adapter_package}"
        else:
            # Regular component installation
            success, message = component_installer.install_component_package(
                dagster_project_path,
                request.component_type
            )

            if not success:
                raise HTTPException(status_code=400, detail=message)

        return {
            "success": True,
            "message": message,
        }

    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/available-components")
async def list_available_components():
    """List all available component packages that can be installed."""
    try:
        components = component_installer.list_available_components()

        return {
            "components": components,
            "total": len(components),
        }

    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/installed-components/{project_id}")
async def list_installed_components(project_id: str):
    """List installed component packages for a project.

    Args:
        project_id: Project ID
    """
    # Get project
    project = project_service.get_project(project_id)
    if not project:
        raise HTTPException(status_code=404, detail="Project not found")

    # Get the Dagster project path using the correct method
    dagster_project_path = project_service._get_project_dir(project)

    if not dagster_project_path.exists():
        return {
            "installed": [],
            "total": 0,
        }

    try:
        installed = component_installer.get_installed_components(dagster_project_path)

        return {
            "installed": installed,
            "total": len(installed),
        }

    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/check-component-installed/{project_id}/{component_type:path}")
async def check_component_installed(project_id: str, component_type: str):
    """Check if a component package is installed.

    Args:
        project_id: Project ID
        component_type: Component type
    """
    # Get project
    project = project_service.get_project(project_id)
    if not project:
        raise HTTPException(status_code=404, detail="Project not found")

    # Get the Dagster project path using the correct method
    dagster_project_path = project_service._get_project_dir(project)

    if not dagster_project_path.exists():
        return {"installed": False}

    try:
        installed = component_installer.is_component_installed(
            dagster_project_path,
            component_type
        )

        return {"installed": installed}

    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
